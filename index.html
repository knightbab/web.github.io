<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebView渲染进程崩溃测试</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .warning h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .warning ul {
            padding-left: 20px;
        }
        
        .warning li {
            margin-bottom: 5px;
        }
        
        .test-section {
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #667eea;
        }
        
        .test-section h2 {
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .test-section p {
            margin-bottom: 15px;
            color: #555;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .crash-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .crash-btn:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }
        
        .warning-btn {
            background-color: #f39c12;
            color: white;
        }
        
        .warning-btn:hover {
            background-color: #d35400;
            transform: translateY(-2px);
        }
        
        .debug-btn {
            background-color: #3498db;
            color: white;
        }
        
        .debug-btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        
        .safe-btn {
            background-color: #2ecc71;
            color: white;
        }
        
        .safe-btn:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }
        
        .debug-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .debug-info.active {
            display: block;
        }
        
        .debug-info p {
            margin-bottom: 8px;
        }
        
        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background-color: #2c3e50;
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
        }
        
        .status.active {
            display: block;
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            color: #777;
            font-size: 0.9rem;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WebView渲染进程崩溃测试</h1>
        <p>用于调试 onRenderProcessGone 接口的测试页面</p>
    </div>
    
    <div class="warning">
        <h3>⚠️ 重要警告</h3>
        <p>此页面仅用于测试和调试目的：</p>
        <ul>
            <li>仅在开发环境中使用</li>
            <li>可能导致WebView崩溃，数据丢失</li>
            <li>部分方法可能导致应用不稳定</li>
            <li>确保已保存所有重要数据</li>
        </ul>
    </div>
    
    <div class="test-section">
        <h2>方法1: 内存耗尽（DOM节点）</h2>
        <p>创建大量DOM节点，试图耗尽渲染进程内存。</p>
        <div class="button-group">
            <button class="crash-btn" id="memoryCrash">触发内存耗尽崩溃</button>
            <button class="warning-btn" id="slowMemory">缓慢内存增长</button>
            <button class="debug-btn" id="showMemoryInfo">显示内存信息</button>
        </div>
        <div class="debug-info" id="memoryInfo">
            <!-- 内存信息将在这里显示 -->
        </div>
    </div>
    
    <div class="test-section">
        <h2>方法2: 堆栈溢出</h2>
        <p>通过无限递归调用函数导致JavaScript调用堆栈溢出。</p>
        <div class="button-group">
            <button class="crash-btn" id="stackCrash">触发堆栈溢出崩溃</button>
            <button class="safe-btn" id="limitedRecursion">有限递归测试</button>
        </div>
    </div>
    
    <div class="test-section">
        <h2>方法3: 主线程阻塞</h2>
        <p>无限循环阻塞主线程，可能导致渲染进程无响应。</p>
        <div class="button-group">
            <button class="crash-btn" id="blockCrash">触发主线程阻塞</button>
            <button class="warning-btn" id="timeoutBlock">定时阻塞（5秒）</button>
        </div>
    </div>
    
    <div class="test-section">
        <h2>方法4: 大量数据操作</h2>
        <p>操作超大型数组和字符串，尝试耗尽内存。</p>
        <div class="button-group">
            <button class="crash-btn" id="dataCrash">触发大数据崩溃</button>
            <button class="debug-btn" id="showDataInfo">显示数据统计</button>
        </div>
        <div class="debug-info" id="dataInfo">
            <!-- 数据信息将在这里显示 -->
        </div>
    </div>
    
    <div class="test-section">
        <h2>方法5: WebAssembly 内存耗尽</h2>
        <p>使用WebAssembly分配大量内存。</p>
        <div class="button-group">
            <button class="crash-btn" id="wasmCrash">触发WebAssembly崩溃</button>
            <button class="debug-btn" id="loadWasm">加载WebAssembly模块</button>
        </div>
    </div>
    
    <div class="test-section">
        <h2>调试工具</h2>
        <p>用于调试和监控的工具。</p>
        <div class="button-group">
            <button class="debug-btn" id="startMonitor">启动性能监控</button>
            <button class="debug-btn" id="logState">记录当前状态</button>
            <button class="safe-btn" id="clearAll">清除所有数据</button>
        </div>
        <div class="debug-info" id="monitorInfo">
            <!-- 监控信息将在这里显示 -->
        </div>
    </div>
    
    <div class="status" id="statusMessage">
        <!-- 状态消息将在这里显示 -->
    </div>
    
    <div class="footer">
        <p>注意：这些崩溃测试可能导致WebView进程终止，触发onRenderProcessGone回调</p>
        <p>适用于Android WebView和iOS WKWebView的崩溃测试</p>
    </div>

    <script>
        // 全局变量
        let memoryMonitorInterval;
        let domElements = [];
        let largeArrays = [];
        let wasmModule = null;
        
        // 工具函数
        function showStatus(message, duration = 3000) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            statusEl.classList.add('active');
            
            setTimeout(() => {
                statusEl.classList.remove('active');
            }, duration);
        }
        
        function showDebugInfo(elementId, content) {
            const el = document.getElementById(elementId);
            el.innerHTML = content;
            el.classList.add('active');
        }
        
        // 方法1: 内存耗尽
        document.getElementById('memoryCrash').addEventListener('click', function() {
            showStatus('开始创建大量DOM节点...');
            
            try {
                const container = document.createElement('div');
                container.id = 'memoryCrashContainer';
                document.body.appendChild(container);
                
                // 创建大量DOM节点
                let count = 0;
                const createElements = () => {
                    for (let i = 0; i < 1000; i++) {
                        const div = document.createElement('div');
                        div.innerHTML = `<div style="padding: 2px; margin: 1px; background: #${Math.floor(Math.random()*16777215).toString(16)};">
                            Memory Item ${count++}
                            ${new Array(1000).join('x')}
                        </div>`;
                        container.appendChild(div);
                        domElements.push(div);
                    }
                    
                    // 递归调用以创建更多元素
                    setTimeout(createElements, 0);
                };
                
                createElements();
                showStatus('正在创建大量DOM节点，可能导致内存耗尽...');
            } catch(e) {
                showStatus(`错误: ${e.message}`);
            }
        });
        
        document.getElementById('slowMemory').addEventListener('click', function() {
            showStatus('开始缓慢内存增长...');
            
            let count = 0;
            const interval = setInterval(() => {
                const div = document.createElement('div');
                div.innerHTML = `<div style="padding: 1px; margin: 1px; background: #f0f0f0;">
                    Slow Memory Item ${count++}
                </div>`;
                document.body.appendChild(div);
                domElements.push(div);
                
                if (count % 100 === 0) {
                    showStatus(`已创建 ${count} 个DOM元素`);
                }
                
                // 在创建10000个元素后停止
                if (count >= 10000) {
                    clearInterval(interval);
                    showStatus('已完成创建10000个DOM元素');
                }
            }, 10);
        });
        
        document.getElementById('showMemoryInfo').addEventListener('click', function() {
            const info = `
                <p>DOM元素数量: ${domElements.length}</p>
                <p>页面总元素数: ${document.getElementsByTagName('*').length}</p>
                <p>内存使用估算: ${Math.round(domElements.length * 0.5)} KB</p>
                <p>Large Arrays: ${largeArrays.length}</p>
            `;
            showDebugInfo('memoryInfo', info);
        });
        
        // 方法2: 堆栈溢出
        document.getElementById('stackCrash').addEventListener('click', function() {
            showStatus('触发堆栈溢出崩溃...');
            
            function recursiveCall() {
                recursiveCall();
            }
            
            // 延迟执行，让状态消息先显示
            setTimeout(recursiveCall, 100);
        });
        
        document.getElementById('limitedRecursion').addEventListener('click', function() {
            showStatus('开始有限递归测试...');
            
            let depth = 0;
            function limitedRecursion(maxDepth) {
                depth++;
                if (depth >= maxDepth) {
                    showStatus(`递归深度达到 ${depth}`);
                    return;
                }
                limitedRecursion(maxDepth);
            }
            
            try {
                limitedRecursion(10000);
            } catch(e) {
                showStatus(`递归错误: ${e.message} (深度: ${depth})`);
            }
        });
        
        // 方法3: 主线程阻塞
        document.getElementById('blockCrash').addEventListener('click', function() {
            showStatus('开始主线程无限阻塞...');
            
            // 无限循环阻塞主线程
            while(true) {
                // 什么都不做，只是阻塞
            }
        });
        
        document.getElementById('timeoutBlock').addEventListener('click', function() {
            showStatus('开始5秒定时阻塞...');
            
            const startTime = Date.now();
            while(Date.now() - startTime < 5000) {
                // 阻塞5秒
            }
            
            showStatus('5秒阻塞完成');
        });
        
        // 方法4: 大量数据操作
        document.getElementById('dataCrash').addEventListener('click', function() {
            showStatus('开始大量数据操作...');
            
            try {
                // 创建超大型数组
                const hugeArray = [];
                for (let i = 0; i < 10000000; i++) {
                    hugeArray.push({
                        id: i,
                        data: new Array(1000).join('x'),
                        timestamp: Date.now()
                    });
                }
                
                largeArrays.push(hugeArray);
                showStatus(`创建了包含 ${hugeArray.length} 个元素的大型数组`);
                
                // 尝试复制数组可能导致内存问题
                const copy = [...hugeArray];
                largeArrays.push(copy);
                showStatus('数组复制完成，可能占用大量内存');
                
            } catch(e) {
                showStatus(`数据操作错误: ${e.message}`);
            }
        });
        
        document.getElementById('showDataInfo').addEventListener('click', function() {
            let totalItems = 0;
            largeArrays.forEach(arr => {
                totalItems += arr.length;
            });
            
            const info = `
                <p>大型数组数量: ${largeArrays.length}</p>
                <p>总数据项数: ${totalItems}</p>
                <p>估算内存使用: ${Math.round(totalItems * 0.1)} MB</p>
            `;
            showDebugInfo('dataInfo', info);
        });
        
        // 方法5: WebAssembly内存耗尽
        document.getElementById('wasmCrash').addEventListener('click', function() {
            showStatus('尝试通过WebAssembly耗尽内存...');
            
            // 如果WebAssembly模块已加载，尝试分配大量内存
            if (wasmModule) {
                try {
                    // 尝试分配非常大的内存
                    const memory = new WebAssembly.Memory({ initial: 10000, maximum: 100000 });
                    showStatus('WebAssembly内存分配成功');
                } catch(e) {
                    showStatus(`WebAssembly内存分配失败: ${e.message}`);
                }
            } else {
                showStatus('请先加载WebAssembly模块');
            }
        });
        
        document.getElementById('loadWasm').addEventListener('click', function() {
            showStatus('加载WebAssembly模块...');
            
            // 简单的WebAssembly模块，分配内存
            const wasmCode = new Uint8Array([
                0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04, 0x01,
                0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0x07, 0x08, 0x01, 0x04,
                0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x0a, 0x04, 0x01, 0x02, 0x00,
                0x0b
            ]);
            
            try {
                WebAssembly.instantiate(wasmCode, {})
                    .then(obj => {
                        wasmModule = obj.instance;
                        showStatus('WebAssembly模块加载成功');
                    })
                    .catch(e => {
                        showStatus(`WebAssembly加载失败: ${e.message}`);
                    });
            } catch(e) {
                showStatus(`WebAssembly错误: ${e.message}`);
            }
        });
        
        // 调试工具
        document.getElementById('startMonitor').addEventListener('click', function() {
            showStatus('启动性能监控...');
            
            if (memoryMonitorInterval) {
                clearInterval(memoryMonitorInterval);
            }
            
            memoryMonitorInterval = setInterval(() => {
                const memoryInfo = `
                    <p>时间: ${new Date().toLocaleTimeString()}</p>
                    <p>DOM元素数: ${domElements.length}</p>
                    <p>大型数组: ${largeArrays.length}</p>
                    <p>页面元素总数: ${document.getElementsByTagName('*').length}</p>
                `;
                showDebugInfo('monitorInfo', memoryInfo);
            }, 1000);
        });
        
        document.getElementById('logState').addEventListener('click', function() {
            const state = {
                timestamp: new Date().toISOString(),
                domElements: domElements.length,
                largeArrays: largeArrays.length,
                totalElements: document.getElementsByTagName('*').length,
                wasmLoaded: wasmModule !== null
            };
            
            console.log('当前状态:', state);
            showStatus('状态已记录到控制台');
        });
        
        document.getElementById('clearAll').addEventListener('click', function() {
            // 清除所有DOM元素
            domElements.forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
            domElements = [];
            
            // 清除数组引用
            largeArrays = [];
            
            // 清除监控
            if (memoryMonitorInterval) {
                clearInterval(memoryMonitorInterval);
                memoryMonitorInterval = null;
            }
            
            // 隐藏调试信息
            document.querySelectorAll('.debug-info').forEach(el => {
                el.classList.remove('active');
            });
            
            showStatus('已清除所有测试数据');
        });
        
        // 页面加载完成
        showStatus('页面加载完成，可以开始测试');
        
        // 添加页面卸载前的警告
        window.addEventListener('beforeunload', function(e) {
            if (domElements.length > 0 || largeArrays.length > 0) {
                const message = '页面有未清除的测试数据，离开可能导致内存泄漏';
                e.returnValue = message;
                return message;
            }
        });
    </script>
</body>
</html>
